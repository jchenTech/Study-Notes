## Abstract详解

abstract一般用来修饰类和方法。
1.abstract修饰类
abstract修饰类，会使得类变成抽象类，抽象类不能生成实例，但是可以作为对象变量声明的类型，也就是编译时类型。抽象类相当于类的半成品，需要子类继承并覆盖其中的方法。
注意：

- 抽象类虽然不能实例化，但是有自己的构造方法。
- 抽象类和接口(interface)有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类可以有实例方法，并实现业务逻辑。
- 抽象类不能被final修饰，因为被final修饰的类无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法。



2.abstract修饰方法

abstract修饰方法会使得这个方法变成抽象方法，也就是只有声明，而没有实现，需要子类重写。
注意：

- 有抽象方法的类一定是抽象类，但是抽象类不一定有抽象方法。
- 父类是抽象类，其中有抽象方法，那么子类继承父类，并把父类中的所有抽象方法都实现了，子类才有创建对象实例的能力，否则子类也必须是抽象类。抽象类中可以有构造方法，子类在构造子类对象时需要调用父类(抽象类)的构造方法。
- 抽象方法不能用private修饰，因为抽象方法必须被子类重写，而private权限对于子类来说是不能访问的，所以就会产生矛盾。
- 抽象方法也不能用static修饰，如果用static修饰了，那么我们就可以直接通过类名调用了，而抽象方法压根没有主体，没有任何业务逻辑，这样就毫无意义了。



3.抽象类的多态性

```java
abstract class E{
    public abstract void show();// public abstract可以省略
}
```

然后其它类继承它通常为了实现它里面的方法。



```java
class F extends{
    void show(){
            写具体代码}
}
```

最后在主方法里定义一个父类引用指向子类对象，就会发生多态现象，比如



```java
E e = new F();
e.show();    
```

实际上调用了子类里面的new()方法。



4.抽象类的构造方法

```java
public abstract class Car {

    Car(){
        System.out.println("抽象方法无参构造函数");
    }
    Car(String a){
        System.out.println("抽象有参构造方法");
    }
    public void mothod1(){
        System.out.println(this.getClass());
        System.out.println("抽象类的实例方法");
    }

    public abstract void mothod2();

}
/**
 * 自行车
 */
class Bicycle extends Car{

    Bicycle(){
        System.out.println("子类无参构造函数");
    }

    @Override
    public void mothod2() {//需要覆写抽象方法mothod2

    }
}
/**另一个包的测试类**/
public class Test {

    public static void main(String[] args) {
        Bicycle b = new Bicycle();
        b.mothod1();
    }
}
```

输出：

```java
抽象方法无参构造函数
子类无参构造函数
class com.shaolin.service.impl.Bicycle
抽象类的实例方法
```



从上面的例子中可以看出：

- 抽象类是有构造方法的（当然如果我们不写，编译器会自动默认一个无参构造方法）。而且从结果来看，和普通的继承类一样，在new 一个子类对象时会优先调用父类（这里指的是抽象类Car）的构造器初始化，然后再调用子类的构造器。至此相信大家都会有这样一个疑问，为什么抽象方法不能实例化却有构造器呢？ 对于这个问题网上也中说纷纭，没有确定答案。
  我是这样想的：既然它也属于继承的范畴，那么当子类创建对象时必然要优先初始化父类的属性变量和实例方法，不然子类怎么继承和调用呢？而它本身不能实例化，因为它本身就是不确定的一个对象，如果它能被实例化，那么我们通过它的对象来调用它本身的抽象方法是不是有问题。所以不能实例化有在情理之中。因此大家只要记住这个规定就行。
- 对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字（静态方法中不能有关键字this，因为static方法可以直接由类名调用，this指代对象，没有实例化就没有对象，所以在static方法中不使用this）代表的是它的继承类，而非抽象类本身，这个好理解，因为抽象类本身不能被实例化。如果有多个继承类，谁调用this就代表谁。

抽象类有什么好处呢？

- 由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。也就是运行期绑定
- 抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。

## abstract和接口的区别

1. 抽象类中可以有普通成员变量，接口中没有普通成员变量。
2. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以是任意的，但是接口中定义的变量只是public static final类型，并且默认为public static final类型。
3. 抽象类可以有构造方法，接口中不能有构造方法。
4. 抽象类中可以包含静态方法，接口中不能有静态方法。这里注意，静态方法不要去重写，其次这里的静态方法一定要有具体实现，不能是抽象的。Java8中允许接口中包含静态方法了，可以用接口直接调用。
5. 抽象类中抽象方法的访问类型可以是public，protected，但是接口中的抽象方法只能是public类型的，并且默认为public abstract类型的。
6. 一个类可以实现多个接口，但是只能继承一个抽象类。

## 关于abstract的一些面试题

**1. Java抽象类可以有构造函数吗？**

可以有，抽象类可以声明并定义构造函数。因为你不可以创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java中构造函数链指的是从其他构造函数调用一个构造函数），例如，当你创建具体的实现类。现在一些面试官问，如果你不能对抽象类实例化那么构造函数的作用是什么？好吧，它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用super()，Java中默认超类的构造函数。

**2. Java抽象类可以实现接口吗？它们需要实现所有的方法吗？**

可以，抽象类可以通过使用关键字implements来实现接口。因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型 。这样的例子是，java.util.List接口和相应的java.util.AbstractList抽象类。因为AbstractList实现了所有的通用方法，具体的实现像LinkedList和ArrayList不受实现所有方法的负担，它们可以直接实现List接口。这对两方面都很好，你可以利用接口声明类型的优点和抽象类的灵活性在一个地方实现共同的行为。Effective Java有个很好的章节，介绍如何使用Java的抽象类和接口，值得阅读。

**3. Java抽象类可以是final的吗？**

不可以，Java抽象类不能是final的。将它们声明为final的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字abstract强制继承类，而关键字final阻止类被扩张。在现实世界中，抽象表示不完备性，而final是用来证明完整性。底线是，你不能让你的Java类既abstract又final，同时使用，是一个编译时错误。

**4. Java抽象类可以有static方法吗？**

可以，抽象类可以声明并定义static方法，没什么阻止这样做。但是，你必须遵守Java中将方法声明为static的准则，因为在面向对象的设计中是不受欢迎的，因为Java中的static方法是不可以被重载的。在抽象类中看到static方法是罕见的，但正如我所说的，如果你有很好的理由这样做的话，那没有什么可以阻止你。

**5. 可以创建抽象类的实例吗？**

不可以，你不能创建Java抽象类的实例，它们是不完全的。即使你的抽象类不包含任何抽象方法，你也不能对它实例化。将类声明为abstract的，就等你你告诉编译器，它是不完全的不应该被实例化。当一段代码尝试实例化一个抽象类时Java编译器会抛错误。

**6. 抽象类必须有抽象方法吗？**

不需要，抽象类有抽象方法不是强制性的。你只需要使用关键字abstract就可以将类声明为抽象类。编译器会强制所有结构的限制来适用于抽象类，例如，现在允许创建一些实例。是否在抽象类中有抽象方法是引起争论的。我的观点是，抽象类应该有抽象方法，因为这是当程序员看到那个类并做假设的第一件事。这也符合最小惊奇原则。

**7. Java抽象类和接口有何不同？**

这是最重要的经典Java面试题之一。我已经记不清多少次看到这个问题了。这个问题有趣的原因是可以举出例子。很容易回答核心OOPS的概念，如抽象，封装，多态和继承，但是，当涉及到微妙点就是这样，候选人往往失手。你可以从本文看出抽象类和接口之间的所有语法的差异。

**8. 何时选用抽象类而不是接口？**

这是对之前抽象类和接口对比问题的后续。如果你知道语法差异，你可以很容易回答这个问题，因为它们可以令你做出抉择。当关心升级时，因为不可能在一个发布的接口中添加一个新方法，用抽象类会更好。类似地，如果你的接口中有很多方法，你对它们的实现感到很头疼，考虑提供一个抽象类作为默认实现。这是Java集合包中的模式，你可以使用提供默认实现List接口的AbstractList。

**9. Java中的抽象方法是什么？**

抽象方法是一个没有方法体的方法。你仅需要声明一个方法，不需要定义它并使用关键字abstract声明。Java接口中所有方法的声明默认是abstract的。这是抽象方法的例子



public void abstract printVersion();

现在，为了实现这个方法，你需要继承该抽象类并重载这个方法。

**10. Java抽象类中可以包含main方法吗？**

是的，抽象类可以包含main方法，它只是一个静态方法，你可以使用main方法执行抽象类，但不可以创建任何实例。



参考文章：

* [Java基础知识详解：abstract修饰符](https://www.cnblogs.com/zuotongbin/p/11717010.html)